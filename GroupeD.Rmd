---
title: "Projet Série chronologie"
author: "Group_D"
date: "2023-01-03"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=FALSE, include=FALSE}
library(ggplot2) #plot basic
library(readr) #read files better
library(lubridate) #to handle dates
library(tidyverse) #include multiple libraries (CHECK IF READR AND GGPLOT2 ARE INCLUDED)
library("readxl") #read excel files library(forecast) #for prediction
library(zoo) #type of data allowing lots of things library(MASS) #for boxcox
library(tseries)
```

### Introduction, présentation et pré-traitement des données:

<p>
Le présent jeu des données renseigne sur la consommation d'électricité en Allemagne du 1 janvier 2016 au 31 décembre 2017, qui peut être téléchargé sur la site kaggle. Il contient un tableau contenant la date, la consommation d'électricité, la production par l'énergie éolienne, la production par l'énergie solaire, la somme de l'énergie éolienne et l'énergie solaire, toutes sont présentées par GWh. Dans un premier temps nous allons chargé les données puis effectuer des pré-traitements des données. les données sont disponible sur le lien dessus
    
https://www.kaggle.com/datasets/mvianna10/germany-electricity-power-for-20062017
</p>

### Vérifion qu'on a bien chargé les données
```{r, echo = FALSE}
data <- read.csv("germany.csv", header = T, encoding = "UTF-8")
data$Date <- as.Date(data$Date)
head(data)
```
Comme pour l'année du 2006 au 2012, la production de l'énergie éolienne et solaire sont des valeurs **na**, nous allons étuidier que les données de l'année 2017 pour diminuer le temps d'exécution et nous allons focaliser dans l'attribut consommation. Voici dessous nous donne des impressions pour cette des données.

```{r, echo=FALSE}
n <- nrow(data)
index <- which(data$Date == as.Date("2017-01-01"))
data_2017 <- data[index: n,]
head(data_2017)
tail(data_2017)
```

### Courbes: La consommation
```{r, echo=FALSE, fig.width=14, fig.height=5, fig.pointsize = 8, fig.fullwidth=TRUE}
win.graph <- 
plot(data_2017$Consumption ~ data_2017$Date, type = "l", col = "blue", xlab = "Date", ylab = "Consommation(GWh)")
points(data_2017$Consumption ~ data_2017$Date, col = "red")
title("Total consommation sur 2017")
```

De 1er janvier 2017 à 31 décembre 2017, la consommation d'électricité est élevé du janvier au mars et du octobre au décembre, et est moins élevé pour la reste. Ceci est raisonnable parce que pendant hiver, les gens utilisent plus d'électricité pour chauffage.

### Traitement de la série chronologie:
On va traiter les données comme une année entière, donc on va mettre le **frequency** = 12 ce qui présente 12 mois, on dans les figures ci-dessous on peut visualiser une tendance et une périocité. Et que le bruit ne suit pas la loi normale.

```{r, echo = FALSE}
data_2017.ts <- ts(data_2017[,2], start = 1, frequency = 12)
plot(decompose(data_2017.ts))
```

### La tendance
Regardons d'abord pour les graphes ci-dessous, on remarqu'il présente une tendance. Mais on ne sait pas trop quelle type de la tendance c'est. Peut-être c'est le type **cos** ou **polynomial** , mais on ne peut pas être sûre. Donc ce que l'on peut faire c'est tout d'abord faire la différentiation de l'ordre 1 pui on peut encore faire une différentiation de l'ordre 7 pour essayer d'annuler l'effet de la saison. Et on va refaire les même figures et faire du test **Augmented Dickey-Fuller Test** pour tester si la série temporelle après le traitement soit une série temporelle stationnaire ou pas.

```{r, echo = FALSE}
data_2017.ts <- ts(data_2017[,2], start = 1, frequency = 1)
plot(data_2017.ts, col = "Violetred2", type = 'l', xlab = "Date", ylab = "Consommation")
title("Total consommation du 2017")
par(mfrow = c(1, 2))
{
    acf((data_2017.ts), lag.max = 365)
    pacf((data_2017.ts), lag.max = 365)
}
```

```{r, echo = FALSE}
adf.test(data_2017.ts)
```
Et le **p-value** ci-dessus nous montre que ce n'est pas une série temporelle stationnaire.

### Elimination de la tendance:

on va donc utiliser l'opérateur de différentiation à l'ordre 1 pour essayer d'éliminer la tendance.

```{r , echo=FALSE}
data_2017.ts.diff1 <- diff(data_2017.ts, lag = 1, differences = 1)
plot(data_2017.ts.diff1, col = "Violetred2", type = 'l', ylab = "consommation")
title("apres élimination 1")
par(mfrow = c(1, 2))
{
    acf((data_2017.ts.diff1), lag.max = 180)
    pacf((data_2017.ts.diff1), lag.max = 180)
}
```

Ce que l'on peut constater que la tendance a été bien éliminée, et on peut constater à partir des graphes **ACF** et **PACF** qu'il y a une période de 7, donc on va essayer de l'éliminer encore par la méthode de la différenciation.

### Elimination de la périodicité
```{r, echo = FALSE}
data_2017.ts.diff2 <- diff(data_2017.ts.diff1, lag = 7, differences = 1)
plot(data_2017.ts.diff2, col = "Violetred2", type = 'l', ylab = "consommation")
title("apres élimination 2")
par(mfrow = c(1, 2))
{
    acf((data_2017.ts.diff2), lag.max = 180)
    pacf((data_2017.ts.diff2), lag.max = 180)
}
```

On note alors la périocité est disparu, L'**ACF** ressemble bien à celui d'un modèle **ARMA**. En revanche en regardant la série et les pics qui dépasse de L'**ACF**, on pourrait tenter de modéliser notre série par **ARMA**

Dans la suite on essaie de trouver un processus **ARIMA** qui modélise bien nos données. on va utiliser la fonction **auto.ARIMA** pour modéliser le modèle qui nous trouve une meilleure modèle.

Et on peut confirmer par le test de DICKEY-FULLER augmenté comme ci-dessous. Le **p-value** est 0.01, donc notre série temporelle est stationnaire.

### TEST de DICKEY-FULLER augmenté
```{r, echo = FALSE}
library(forecast)
adf.test(data_2017.ts.diff2)
```

L'**ACF** et le **PACF** des résidus ressemblent à un bruit blanc. 

### Choix du modèle

Comme notre série est stationnaire, on peut essayer d'appliquer le modèle ARIMA puis SARIMA parce que c'est une série saisonnière. On va tout d'abord utiliser la fonction auto.arima pour déterminer les paramètres du modèle pour avoir notre premier modèle puis on va ajouter les paramètres saisonnière pour comparer les 2 modèle et voir lequel est le meilleur.

```{r, echo = FALSE}
model1 = auto.arima(data_2017.ts.diff1, stationary = TRUE, seasonal = TRUE, max.p = 100, max.q = 100)

summary(model1)
plot(model1$residuals, main = "résidu par rapport du temps")
boxplot(model1$residuals, main = "Boxplot des résidus")
par(mfrow = c(1,2))
{
    acf(model1$residuals)
    pacf(model1$residuals)
}

qqnorm(model1$residuals)
qqline(model1$residuals)
```
On obtient un modèle ARIMA de paramètre (3,0,3).

Nous pouvons constater que l'ACF et l'PACF nous ressemblent que ce n'est pas un bruit blanc. Le QQ-plot des résidues ne ressemble pas trop à la loi normale, on va tester quand même l'effet de la prédiction. Pour la prédiction, on fixe les 30 derniers jours pour le tester, les autres données comme les données training.

```{r, echo = FALSE}

n <- 30
train <- data_2017.ts[1:(length(data_2017.ts) - n)]
test <- data_2017.ts[(length(data_2017.ts) - n) : length(data_2017.ts)]

model2 <- Arima(train, order = c(3,0,3))

result <- forecast(model2, h = n, level = c(95))

plot(result)

```

On peut remarquer qu'il reproduit les même pics et il est loin de figure originale, donc on essaie un autre modèle SARIMA.

### Modèle SARIMA
on peut utiliser la fonction **nsdiffs** et **ndiffs** pour déterminer les paramètre saisonière du modèle SARIMA, on obtient SARIMA(3,0,3)(0,1,0)7. Et on refait la même chose.

### Prédiction

```{r, echo=FALSE}
model3 <- Arima(train, order = c(3,0,3), list(order = c(0,1,0), period = 7), include.mean = FALSE, method = "CSS-ML")
plot(model3$residuals, main = "résidu par rapport du temps")
boxplot(model3$residuals, main = "Boxplot des résidus")
par(mfrow = c(1,2))
{
    acf(model3$residuals)
    pacf(model3$residuals)
}

qqnorm(model3$residuals)
qqline(model3$residuals)
```

On peut constater depuis les graphes ACF et PACF que c'est mieux que le modèle précédent, et pour le qq-plot, on constate que la plupart du points résidus sont dans la droite. Mais c'est étonnant que dans le queue et la tête des points sont éloignés. On va effectuer la prédiction pour ce modèle pour voir est-ce qu'il est mieux que le modèle précédent.

```{r, echo = FALSE}

result <- forecast(model3, h = n, level = c(95))

plot(result)

```

On remarque la prédiction est mieux que celui précédent.

### Conclusion

Pour la conclusion, nous n'avons pas réussi à modéliser la consommation d'électricité parce que le modèle qu'on a choisit, les résidues ne suivent pas la loi normale, et nous avons essayé 2 modèles, ARIMA et SARIMA, le meilleur entre ces 2 est un peu loin de la réalité. 

Peut-être c'est parce que dans cette base des données, le bruit n'est pas assez aléatoire. Ou peut-être on doit essayer d'autre modèle.

### Bibliographie
1. https://www.themachinelearners.com/series-temporales-arima/
2. https://www.dataquest.io/blog/tutorial-time-series-analysis-with-pandas/
